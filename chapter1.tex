\chapter{INTRODUCTION}

%Gordon: 

% Introduction describes the setting for what you want to do. Tell a story. Why are you doing this work? What are the issues? What are the objectives?

% describe what blender is, how popular it is, what it does, why people like it, its advantages, etc.

% Why flocking? What can one do with flocking? Surely you read articles? Armies, animals, population, better games, etc., etc. Why are we doing flocking? What can we achieve? Why Blender?

%What have you done? What are you hoping to do with your implementation?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% why people like games?
% creating games
% what a game must have in order to be a good game?

Computer games have been around since the 1950s\cite{computerVideoGamesHistory}. They were available in the market place by the 1970s and they were very popular. More and more games have been developed since then. The present time is in the seventh generation of video game consoles\cite{seventhGenerationGames}. Video consoles like PlayStation, Xbox, and Wii are the most popular ones. In November 2010, Xbox release their new control-free body play experience called Kinect\footnote{http://www.xbox.com/en-US/kinect}. This new hardware changed the game industry by allowing the player to control the game experience with their own moves. Hardware like this make the developing of games more fun. 

\textit{How to know if a game is a good game?} A game, to be attractive to players, should have at least three important aspects\cite{bookGameKit2}. First is the toy aspect, this refers to immediate fun that you can have playing the game. You would not need to read any manual to play it, you just grab the controller or the mouse and start playing it. This kind of games are more intuitive. Second is the immersive aspect of the game. This is when you are playing a game and you completely forget that you are playing. Realism is a very important factor in here. An example of immersive games are simulator games. Third is the goal aspect. This games give you a goal that you have to achieve, and involve some kind of strategy and planning. When creating games it is important to create balance between these aspects. But, \textit{how to create the games?} Games are created using game engines.

% different software to create games available
% why Blender?

Currently, there are some commercial and free game engines available. Our interest in one for educational purposes that have the capability of been extended (open source), that is cross-platform between Windows, MacOSX and Linux, and that also can support simulation with real physics. 

% benefits and difficulties of using Blender
% Blender contents

While Dr. Gordon Erlebacher searched for software to teach his \textit{Introduction to Game Design} class for the first time, he found that Blender\footnote{http://www.blender.org} met all the requirement mentioned above, plus it was free. Blender was created 1993, first just to create 2D and 3D content and currently, it can be used to do modeling, texturing, animation, particle simulation, rendering, and game creation just to name a few. The Blender Game Engine has powerful tools to create games without the need of any explicit programming. Blender has a big support from the gaming industry and there is a lot of documentation available for it.  

% Blender Particle Systems
% issues between the Particle systems and the Game Engine

There are some additional tools that are not available for the Blender Game Engine, those tools are only available for simulations or animations, for example. One of those tools is the Particle Systems which is used to simulate particles using different types of physics i.e. Newtonian, Boids\footnote{Entities that have flocking behavior.}, and Keyed physics. 

% why flocking?
% summary of flocking

% define the problem and mention the approaches to solve it

Newtonian physics are normal particle physics. The particles start with an initial velocity and an angular velocity.  The particles move according to the forces calculated between them. Another system available is the Boids particle system. Boids systems follow some basic rules and behaviors, and they are used to simulate flocks, schools, herds, and swarms of different entities.

This thesis project will focus on the Boids system. Boids can be defined as entities, in most cases animals, that have an emerging behavior caused by following a set of rules called steering behaviors. This behavior is called \textit{flocking} and the name Boids was first introduced by the pioneer of flocking, Craig Reynolds in his 1987 published paper Flocks, Herds, and Schools: A Distributed Behavioral Model\cite{craig1}. The model presented by Reynolds have been used by many scientist interested in this research area\footnote{More information about this is going to be discussed in the next chapter.}.

Following the basic flocking model described by Reynolds in his 1987 paper, the flocking algorithm to be used in the Blender Game Engine was developed. Sure you are thinking that there has been many publications after the first approach, \textit{Yes}!  Since the initial approach, the algorithm have not changed much, the modifications that distinguish each publication are basically in the how they compute the steering behaviors.

To implement this flocking algorithm the Blender Game Engine source code was modified, and this implies that eventually Blender has to built again. The property of the portability of Blender should be kept when taking decisions on how to modify Blender's source code. This was not and easy job. This thesis was based on the latest Blender release 2.57. 

% may need a connection sentence between this paragraphs

Even though the Blender Game Engine tries to display games at a speed of 60 frames per second\cite{bookGameKit2} if the CPU or graphics card is not good enough the engine will start dropping down some frames in order to get into a state in which the speed of all objects is maintained. Therefore, the computationally-intensive parts of the code were accelerated and the scenes were efficiently render. These was achieved by doing those computations in the Graphics Processor Units (GPUs) which are computation-dedicated devises that can perform vector operations in the data. GPUs have been very popular for the last years in different research areas. 

The programming language chosen for the GPU does not depend on an specific type of card. Blender already have the platform portability property and portability between different graphics cards must be maintain too. That is why OpenCL was selected as the language to be used for coding the computationally-intensive parts of the code that was accelerated. CUDA is a more popular GPU programming language but it works only on NVIDIA graphics cards. OpenCL ensures the portability between different GPUs.

%Why are you doing this work? What are the issues? What are the objectives?
%What have you done? What are you hoping to do with your implementation?

The GPU code is outside Blender. My colleague Ian Johnson\footnote{http://enja.org/} developed a library named \textit{RTPS} (Run-Time Particle Systems) which basically defines particle systems that can be used inside Blender Game Engine. He worked in a system that simulates real-time fluids using Smooth Particles Hydrodynamics. This code was extended in order to implement flocking behavior. The three basic rules plus some other extra behaviors were implemented inside RTPS. RTPS also, takes care of all the rendering.

An interface in the Blender Game Engine was developed in order to link with the RTPS library. This interface is a modifiers in the Modifier System. This modifier was called RTPS. This modifier allow us to applied properties to objects inside Blender Game Engine and do interactions between Particle System and Blender's objects.

Both the RTPS library and Blender modifier were expanded in order to enhance the capabilities of the main implementation done by Ian Johnson.

% guide to the reader of the content of the thesis

This thesis continues as follows, next chapter describes some of the related work that have been done in the flocking research area. Chapter 3 shows the algorithms and rules implemented. Chapter 4 describes the features of the RTPS library. In Chapter 5, the Custom Modifier that was developed for Blender and some other properties defined to be able to interact with other Blender objects are presented. Chapter 6 shows demos and benchmarks. Finally, Chapter 7 presents the conclusions and Chapter 8 states the future work. 
