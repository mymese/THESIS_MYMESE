\chapter{INTRODUCTION}

%Gordon: 

% Introduction describes the setting for what you want to do. Tell a story. Why are you doing this work? What are the issues? What are the objectives?

% describe what blender is, how popular it is, what it does, why people like it, its advantages, etc.

% Why flocking? What can one do with flocking? Surely you read articles? Armies, animals, population, better games, etc., etc. Why are we doing flocking? What can we achieve? Why Blender?

%What have you done? What are you hoping to do with your implementation?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% why people like games?
% creating games
% what a game must have in order to be a good game?

Games have been around since the 1950s\cite{computerVideoGamesHistory}. They were available in the market place by the 1970s and they were very popular. More and more games have been developed since then. At current time we are in the seventh generation of video game consoles\cite{seventhGenerationGames}. Video consoles like PlayStation, Xbox, and Wii are the most popular ones. In November 2010, Xbox release their new control-free body play experience called Kinect\footnote{http://www.xbox.com/en-US/kinect}. This new hardware changed the game industry by allowing the player to control the game experience with their own moves. Hardware like this make the developing of games more fun. 

\textit{How to know if a game is a good game?} A game to be attractive to players should have at least three important aspects\cite{bookGameKit2}. First is the toy aspect, this refers to immediate fun that you can have playing the game. You would not need to read any manual to play it, you just grab the controller or the mouse and start playing it. This kind of games are more intuitive. Second is the immersive aspect of the game. This is when you are playing a game and you completely forget that you are playing. Realism is a very important factor in here. An example of immersive games are simulator games. Third is the goal aspect. This games give you a goal that you have to achieve, and involve some kind of strategy and planning. When creating games it is important to create balance between these aspects. But, \textit{how to create the games?}

% different software to create games available
% why Blender?

Currently, they are some commercial and free game engines available. We are interested in one for educational purposes that have the capability of been extended (open source), that is cross-platform between Windows, MacOSX and Linux, and that also can support simulation with real physics. 

% benefits and difficulties of using Blender
% Blender contents

While Dr. Gordon Erlebacher searched for software to teach his \textit{Introduction to Game Design} class for the first time, he found that Blender\footnote{http://www.blender.org} met all the requirement mentioned above, plus it was free. Blender was created 1993, first just to create 2D and 3D content and currently, it can be used to do modeling, texturing, animation, particle simulation, rendering, and game creation just to name a few. Blender Game Engine has very powerful tools to create game without need of any programming. Blender has a big support from the gaming industry and there is a lot of documentation available for it.  

% Blender Particle Systems
% issues between the Particle systems and the Game Engine

They are some tools that are not available for the Blender Game Engine, while you still can used them if you want to do something else like a simulation or an animation. One of those tools is the Particle Systems which are used to simulate particles using different types of physics i.e. Newtonian, Boids\footnote{Entities that have flocking behavior.}, and Keyed physics. 

% why flocking?
% summary of flocking

% define the problem and mention the approaches to solve it

Newtonian physics are normal particle physics. The particles start with an initial and angular velocities and move according to the forces. They are four types of integrators to choose from: Forward Euler, Second Order Runge-Kutta, and Fourth Order Runge-Kutta. Another system is Boids particle system. Boids' systems follow the basic rules and behavior. They are use to simulate flocks, schools, herds, and swarm of different entities.

This thesis project will focus on the mentioned above Boids' systems. Boids can be defined as entities that in most cases are animals that have an emerging behavior caused by following a set of rules called steering behaviors. This behavior is called \textit{flocking} and the name Boids was first introduced by the pioneer of flocking, Craig Reynolds in his 1987 published paper Flocks, Herds, and Schools: A Distributed Behavioral Model\cite{craig1}. The model presented here by Reynolds have been used by many scientist interested in this research area\footnote{More information about this is going to be discussed in the next chapter.}.

Following this basic flocking model we implemented this behavior in the Blender Game Engine. Sure you are thinking that there has been many publications after the first approach, \textit{Yes}!  Since the initial approach, the algorithm have not change much, the modifications that distinguish each publication from each other are basically in the way that they compute the steering behavior.

To implement this we modified the Blender Game Engine source code, and this implies that eventually we had to built Blender again on our own. We would like to preserve the property of the portability of Blender while we modified Blender's source code. This was not and easy job. We worked on the latest Blender release 2.56a Beta. 

% may need a connection sentence between this paragraphs

Even though Blender Game Engine try to play the games in 60 frames per second\cite{bookGameKit2} if the CPU or graphics card is not good enough the engine will start dropping down some frames in order to get into a state in which the speed of all objects is maintain. Therefore, we accelerated the computationally-intensive parts of the code and efficiently render the games. We achieved this doing those computations in Graphics Processor Units (GPUs) which are computation-dedicated devises that can perform vector operations in the data. GPUs have been very popular for the last years in different research areas. 

We chose a computer language for the GPU programming that does not depend on an specific type of card. Blender already have the platform portability property  and we wanted to have portability between different graphics cards too. That is why OpenCL was selected as the language to be used for coding the computationally-intensive parts of the code that we accelerated. CUDA is a more popular GPU programming language but it does run only on NVIDIA graphics cards. OpenCL ensures the portability between the different GPUs.

%Why are you doing this work? What are the issues? What are the objectives?
%What have you done? What are you hoping to do with your implementation?

This GPU code is outside Blender. My colleague Ian Johnson\footnote{http://enja.org/} developed a library named \textit{RTPS} (Run-Time Particle Systems) which basically defines particle systems that can be used inside Blender Game Engine. He worked in a system that simulates real-time fluid using Smooth Particles Hydrodynamics. We extended his code to implement flocking behavior. The three basic rules plus some other extra behaviors were implemented inside RTPS. RTPS also, takes care of all the rendering.

An interface in the Blender Game Engine was developed in order to link with the RTPS library. This interface is a Custom Modifiers in the Modifier System. We called this Custom Modifier, RTPS. With this modifier we can applied properties to objects inside Blender Game Engine and do interactions between Particle System and Blender's objects.

Both the RTPS library and Blender Custom Modifier were expended in order to enhance the capabilities already implemented by Ian Johnson.

% guide to the reader of the content of the thesis

The thesis continues as follows, nest chapter describes some of the related work that have been done in the flocking research area. Chapter 3 shows the algorithms and rules implemented. Chapter 4 describes the features of the RTPS library. In Chapter 5, we show the Custom Modifier that was developed for Blender and some other properties defined to be able to interact with other Blender objects. Chapter 6 shows an example in which both systems developed in RTPS are interacting. Finally, Chapter 7 presents the conclusions and future work. 
