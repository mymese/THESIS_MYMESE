\chapter{RELATED WORK}\label{chap2}


%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%
%\section{Introduction}
Flocking is a nature-inspired behavior that is mostly seen in birds. 

The pioneer of flocking, Craig Reynolds, defined flocking as \textit{the result of the interaction between the behaviors of individual birds}\cite{craig1}. Since its publication in 1987 the field of flocking has grown rapidly. %Research work related to flocking started to been developed by mid 1980s. 

This chapter discusses some of the related work that has been done in flocking. \old{We first goes as follows} We first discuss early work of Craig Reynolds and some of the research that followed in the area of flocking. We then present a brief summary of GPU computing, and how flocking algorithms have been dramatically accelerated.  \old{and some work that has been done with flocking and GPUs.} The final section talks about Educational Games and how they might be served by the incorporation of a flocking module.  \old{some of the approaches that have been done with Flocking and Games.}


%%%%%%%%%%%%%
% Computational Intelligence
%%%%%%%%%%%%%
%\section{Computational Intelligence}

% Swarm intelligence
%\subsection{Swarm Intelligence} 
%Swarms are seen in nature mostly as large groups of small insects \cite{?}. Each entity of a swarm performs a simple role that evolves into a complex behavior as a whole. The emerge of this complex behavior goes beyond swarm since it can also be seen in social animals like birds and fishes. 

% take a picture of a flock to add it here 

%Each entity of a swarm will follow a set of simple rules which depends from the entities of the swarm. Every time the rules are changed the environment conditions are evaluated. Since this process is sometimes very simple researches started trying to model it. Therefore, a new discipline in the area of artificial intelligence started to growth.

%In 1989 Gerardo Beni and Jing Wang introduced the term Swarm Intelligence (SI) to the Artificial Intelligence (AI) community. SI was born in order to understand the biological insights about the ability of social life insects to solve their everyday problems \cite{BioPrinciplesSI}. As many areas of science, researchers give different definitions to it. XXXX and XXX defined SI as an AI discipline that studies the self-organized behavior of multi-agent systems \cite{?}. 

%Lets explain what is self-organized behavior and multi-agent systems are and were are they used for. Self-organized behavior.

% mention ACO and PSO

% Evolutionary computation
%\subsection{Evolutionary Computation}

% mention GA


%%%%%%%%%%%%%
% Flocking
%%%%%%%%%%%%%
\section{Flocking}
Flocking became very popular in the late 1980s, when, inspired by the behavior of birds, Craig Reynolds developed a behavioral model that simulates self-organizing boids\footnote{A boid is synonymous with one entity taken from a flock.} This led to much research and a wide range of applications. We discuss some of these in this section.  \old{After this development, flocking became very popular and many applications of it have been published.} \old{A discussion of some of this work that have been done after the development of the Boids model and also some of the applications of flocking are going to be mentioned.}

% Early work by Craig Reynolds
\subsection{Original Boids Model by Craig Reynolds}
Flocking became very popular ince Craig Reynolds published his flocking model called \textit{Boids}\cite{craig1}. Reynolds introduced the word Boid to denote a \textit{simulated bird-like, \textbf{bird-old} object generically even when they really represent other entities such as schooling fish}. \old{Reynolds} The original model was inspired by the flocking behavior observed of birds. The contributions in the original paper inspired \old{on this paper made more} many researchers to become interested in studying this naturally-inspired behavior.

His flocking model was inspired by the observed bird behavior in flight. \old{ and the aspects of the physics of their flight.} Several basic assumptions led a a simple set of rules that could approximatley model the coarse characteristics of bird flight, combining randomness with obvious correlation between the flight trajectories of individual birds.  
\old{The behaviors of the boids are represented with rules and the internal state of each of them is stored in a data structure. The geometric flight of each boid is the motion along the path it is traveling. Geometric flight relates translation, pitch and yaw.}

The flight of natural flocks balance between a desire to stay close to each other and the need to avoid collisions. \old{with their neighbors.} 
This balance leads to the definition of the Boid model. The first rule defined by Reynolds is \textit{collision avoidance}: each boid will adjust its trajectory to move away from neighbors that are too close;  \old{going to avoid collisions with their nearby flockmates;} the second rule is \textit{velocity matching}: in the absence of other considerations, the boids want to move at the same velocity as their neighbors. In other words, the flock wants to maintain its strucdture. \old{the this rule attempts to match the velocity of the boids with the nearby flockmates;} The last rule is \textit{flock centering}: boids tend to form clusters by moving closer to their flockmates. \old{which tries to make boids closer to their flockmates.}

Collision avoidance is based on the relative positions while velocity matching is based only on the velocities; they are therefore complementary rules. Flock centering steers each boid 
towards the center of the flock. 

From an implementation point of view, each boid stores its internal state and 
evaluates each of the rules individually based on the flockmates in some prescribed neighborhood. 
In practice, the neighborhood is defined as a spherical zone around the boid's local origin.
When Reynolds ran his experiments, initial positions, velocities, and various parameters were initialized with random values. 

When avoiding collisions with obstacles, the boids react in  way that depends on the force field that surrounds them. Naturally, the boids only consider objects that are in front of them. The naive implementation of the original Boids model \old{developed by Reynolds in 1987} had an operation count of $O(N^2)$, where $N$ is the number of boids in the flock. This reflects the dominant cost of the neighbor search. He also performed a parallel implementation that was $O(N)$ with respect to the population.
\mmy{What do you mean: O(N) with respect to the population?}

\old{This paper was successful in the development of an algorithm that simulates independent boids that try to avoid collisions with themselves and with obstacles objects in the environment, while also being able to stick together.}

% Current work
\subsection{Previous Flocking Work}\label{currentwork}
Since the publication of the original Boids model, \old{Craig's paper describing the Boid model}, many papers have been published on flocking. \old{in this area.} The research has \old{Some researchers} has focused on expanding the list of the steering behaviors, enhancing the neighbor search, analyzing the different types of  boid formations, or just applying flocking or modified flocking algorithms to an specific research problem.
\mmy{YOU SHOULD PROVIDE MANY REFERENCES IN THIS LAST PARAGRAPH}

\mmy{You say that since Reynolds work there have been many papers, and the first paper you reference is 12 years after the first!!! There was nothing between 1987 and 1999?}
In 1999, Reynolds published another paper in which he introduced additional steering 
behaviors to define autonomous characters\cite{craigSteeringBehaviors}. 
Autonomous characters are agents in the animations or games that do not need to be 
controlled because they improvise their actions and moves. In games, these agents are 
called non-player characters (NPC). The motion behaviors of an autonomous character 
can be divided into three layers: action selection (strategy, goals, and planning), steering behaviors (path determination), 
and locomotion (animation). 
Reynodld focussed on the second layer. The steering behaviors presented were:
\begin{enumerate}
\item \textbf{seek}: boids steer towards a static target in global space
\item \textbf{flee}: the inverse of seek, boids steer away from the target in global space
\item \textbf{pursuit}: similar to seek but the target is a moving object
\item \textbf{evasion}: similar to flee but the target is a moving object
\item \textbf{offset pursuit}: steer the path to pass \textit{near to} but not \textit{directly to} the moving object
\item \textbf{arrival}: similar to seek, but the character is far from the target
\item \textbf{obstacle avoidance}: gives the character the ability to maneuver in the environment while not colliding with the obstacles 
\item \textbf{wander}: random steering
\item \textbf{path following}: steer along a predetermined path
\item \textbf{wall following}: variation of path following, approach a wall and maintain a certain offset from it
\item \textbf{containment}: variation of path following, motion is restricted to a region
\item \textbf{flow field following}: steers the position of the character in direction to the flow
\item \textbf{unaligned collision avoidance}: prevents collision between characters that are moving in arbitrary directions
\item \textbf{separation}: maintain certain separation from others nearby
\item \textbf{cohesion}: steers towards the center of nearby characters
\item \textbf{alignment}: align itself with nearby characters
\item \textbf{flocking}: combination of separation, alignment, and cohesion
\item \textbf{leader following}: one or more characters follow another moving character (leader)
\item \textbf{interpose}: try to put a character in between two moving characters
\item \textbf{shadow}: approach a character and then use alignment to match their speed and heading
\item \textbf{hide}: identify the position of a target that is on the opposite side of an obstacle and  steer towards it using seek
\end{enumerate} 
 
The behaviors mentioned above can be combined to produce more complex patterns of behavior. Later in 2000, Reynolds published another paper\cite{craigInteractionGroups} in which he focussed on the interaction of large groups of autonomous characters in real-time. 

Von Mammen did a study on the time evolution of flock topology, which 
depends on the dynamic change of the neighbor search\cite{spatialSwarms}. 
Marina Klotsman and Ayellet Tal  did a classification of the different flock formations\cite{lineFormations}. They classify them in two groups: \textit{cluster} and \textit{line} formations.
\mmy{THAT IS IT? NOTHING MORE TO SAY?. YOu only mention two papers aside from Reynolds? Nothing more to be said?} 

\subsubsection{Applications}
There are numerous applications of \old{The application areas of flocking are numerous,} 
ranging from bio-inspired systems to clustering. \mmy{and a few more please}
We present some pertinent results from these application areas. 
One of the nature-inspired applications of flocking is prey/predator\cite{gems2}. 
{\old{Flocking can be used to handle both, the group of preys and the group of predators\cite{gems2}.} Also, crowds simulation are by definition a flocking phenomenon and have been 
considered in \cite{crowdsPS3}. 

In the area of robotics, Yang et al. developed a collision avoidance flocking algorithm 
based on the use of convex objects as obstacles\cite{flockingRobots}. They defined four states that a robot may be in: wait, observe, compute, and move. The life of these robots was a defined sequence of cycles of these states. The practical objective of the research was 
enhanced rescue operations after severe earthquakes and space exploration, two use
cases in which humans would have a difficult time. The authors found that the algorithm they developed can efficiently adapt to complex environments. Lindhe also focused in using a flocking algorithm to displace a group of robots. The implementation was actually tested on 
real robots\cite{flockingRobotsThesis}. Lindhe prioritized the different components 
of his algorithm. 
The highest priority would be safety which implies collision avoidance. Next is 
goal convergence, followed by cohesion. He found that when robots were moving in open fields they stay clustered in a formation that facilitates communication between the robots. 

Unmanned air vehicles (UAV) can be related to robotics. Crowther focuses in civil and military applications of  UAV\cite{flockingUAV}. Crowther determined that using only cohesion and alignment was sufficient to generate the desired behavior. Another investigation of UAVs basedon flocking behavior was conducted by Ryan et al\cite{UAVControl}. \old{They used flocking for UAV control.} They implemented collision avoidance with respect to other UAVs and obstacles. \old{was implemented.}

In 2006 Cui et al. presented a flocking-based approach for document clustering\cite{document1}. In this study each document is represented by a boid. A fourth rule was added to drive the flocking behavior \old{They conducted the study using the three basic flocking rules plus they added another rule which they called} based  feature similarity and dissimilarity. This 
additional rule is what made the actual classification possible. \old{This rule is introduced in order to do the classification.}

Finally, we mention a variation on the flocking concept.  
\old{application be mentioned is a variation of flocking,}
Influence maps, used to implement the flocking behavior, are compared to the 
traditional implementation of flocking\cite{flockingInfluenceMaps}. 
The influence map procedure outperforms the traditional procedure for large 
compact and for large flocks in general. Many other applications of flocking are currently investigated, here only a few of them were mentioned.
\mmy{WHAT do you mean by "large compact"?}

%%%%%%%%%%%%%
% GPU Computing
%%%%%%%%%%%%%
\section{GPU Computing}
Graphical Processing Units (GPUs) can be found on virtually every computer, and offer
the possibilty of 10x to 50x increase in speed for a large class of algorithms, namely 
those amenable to SIMD (Single Instruction Multiople Data)  parallelization. 
\textit{GPU computing}, also known as GPGPU, is a field of study that develops
the use of graphic processors for general computing rather than graphical application. 
Over the past decade, scientists and engineers have increasingly been taking 
advantage of GPU computing to enhance the performance of their applications.
\old{is when using GPUs for general computing.} 
\old{The GPUs stand for \textit{Graphics Processing Units}, and they are devices that were originally created to do graphics, general imaging and games.}

GPU computing is often considered to be an heterogeneous system, a mixture of 
GPUs and CPUs used together to process one or more tasks. 
Typically, sequential code is implemented on CPU and the 
computationally-intensive, and parallelizable code is relegated to the GPU.

Although there are have been many languages developed for the GPUs over the past decade, 
the two most prevalent are 
\old{Two of the most widely spread GPU programming languages are CUDA and OpenCL.}
Because flocking is at its core a massively parallel concept (each member of a flock is 
treated to the identical algorithm}, GPUs seem like a natural fit to 
to improve algorithm performance, opening the door to flocks with 
tens or hundreds of thousands of boids. Examples of super-flocks would include 
armies of ants and the migration of butterflies. 
\mmy{NEED REFERENCES: armies of ants, and butterflies}

% GPU device
\subsection{Programmable GPU}
A GPU device is a numeric computing engine\cite{GPUbook} that focuses on 
performing a massive number of floating-point calculations in parallel. 
\old{The floating-point horsepower of a GPU overcomes the CPU.}
GPUs have a vector architecture that has significant advantages when executing 
identical operations on arrays whose data is stored sequentially in memory. 
\old{vectorial operations.} They have many Arithmetic Logic 
Units with small control unit and a small cache memory. To the contrary CPUs, 
have a large logical control unit and a large cache. 
\old{This is because CPUs are made only to improve sequential code performance.}

\old{GPU architecture is evolving more rapidly than dictated by Moore's law. 
A new card is output on a six month cycle.  NVIDIA\cite{nvidia}, 
one of two companies that dominates the world GPU market  
duplicate their current computational power on the GPUs, allowing graphics artists, game developers and scientists to improve their work in quality and quantity. }
\mmy{I HAVE NO IDEA WHAT YOU ARE SAYING}

% GPU programming languages
\subsection{GPU Programming Languages}
Since the GPUs have a different architecture than the CPUs, they need to be 
programmed in a special manner. Two of the most known programming languages used 
for GPU programming are CUDA and OpenCL. 
\mmy{Already stated. You repeat yourself a lot}. 
CUDA is the NVIDIA  general purpose application programming interface (API)\cite{CUDAandOpenCL}, while OpenCL belongs to Khronos Group. \mmy{No reference for OpenCL?}
OpenCL, which is an extension to the C-language,  enables different 
computing devices to execute OpenCL code, and exchange data; this is not 
possible with CUDA. \old{OpenCL is a C-language extension.}
 
% Flocking in GPU
\subsection{Flocking in GPU}\label{flockingGPU}
Flocking algorithms can take advantage of GPU-based implementations. 
Era et al. developed a GPU-based library for autonomous character called BehaveRT\cite{BehaveRT}. This library can be used to perform simulations in real-time and visualize large groups of individuals. BehaveRT was implemented using CUDA. They were able to run 130K individuals at 15 FPS on a NIVIDIA 8800GTS card. \textit{Boids that See}, proposed a self-occlusion GPU flocking implementation that allows groups of up to 65,000 boids at 30 FPS\cite{boidsThatSee}. 

Other applications of flocking have been also implemented in the GPU.  Crowd simulations of more than 1 million boids have been performed\cite{supermassiveCrowd} at interactive rates of 25 FPS. \old{The frame rate of this simulation was 25 FPS.} 
Weiss developed a ClusterFlockGPU algorithm\cite{SI_GPU} \old{. ClusterFlockGPU was implemented} in CUDA; and it was possible to achieve feasible results for large groups of up to 5000 instances at 12 FPS. Clustering of documents has also been implemented on the GPU\cite{document2}, and achieves a 5x speedup relative the CPU for 3,000 documents. 
\old{The last application to mention is document clustering, the GPU implementation clusters 3,000 documents 4.6 faster than in the CPU\cite{document2}.}

%%%%%%%%%%%%%
% Educational Games
%%%%%%%%%%%%%
\section{Educational Games}
Games can be classified into multiple categories, such as shooter games, sport games, 
massively multiplayer games. Any one of these categories can be recast to have an 
educational component, thus the emergence of
educational games. This class of games tries to address the poor performance in 
mathematics and the sciences in American schools, and the increase in the number of hours spent gameplayer by many individuals. Thus, we feel that it is important to incorporate 
general tools such as flocking into public domain game engines to 
provide game writers increased flexibility to develop software to help students learn within an environment they are comfortable with. While games already contain flocking and particle modules, they are most often running on the CPU, so real-time interactivity is not possible, except for small flock sizes. 
\old{such as incorporating tools in games that    which are games that teach the user.}
Some of the academic areas that educational games have dealt with \old{focus are} 
language and literacy, mathematics, history, and science\cite{makingDesignGames}. 

Three issues that have to be addressed while integrating educational content in computer games are\cite{educationalComputerGames}:
\begin{enumerate}
\item{matching educational topics with their most appropriate media}
\item{providing educational content during the game, so that player can think while playing 
the game}
\item{built feedback and hint structures to support the player} 
\end{enumerate} 
Some of the benefits of educational games are gain of knowledge, motivation, and interest. A game must have fantasy, curiosity, and it must be challenging. Creating compelling 
educational games is no easy task. If it is too easy, the students do not learn, if too 
difficult, the students are frustrated, if it is too obvious that the game is meant to teach, the student might not be interested in playing. Ultimately, the game must combine challenge, fun, and provide a learning curve that is adapted to the player 
\cite{computerGamesEducationalTool}.

% Flocking games
\subsection{Flocking Games}
Steven Woodcock published a code in the book Game Programming Gems 
in which he considered flocking as a simple technique to simulate group 
behavior\cite{gems1}. 
In this code, he implemented four rules: separation, alignment, cohesion, 
and avoidance.  One advantage of flocking that can be taken into account is its
stateless nature, the state of each boid does not depend on its state at the previous
step, thus conserving on memory. \old{no information has to be stored at each update step.} 
Flocking can be used in games to enhance the \textit{illusion of reality} for the user. 
In 2001 Woodcock \old{published on the 2nd edition of Game Programming Gems. In here, he}
describes an application of flocking inspired by predators and prey \cite{gems2}. 
He also implemented obstacle avoidance.

